package com.pentest.browser;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import org.json.JSONObject;
import org.json.JSONArray;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.TextField;
import org.apache.lucene.document.StoredField;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.store.FSDirectory;
import org.apache.lucene.search.Query;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TopDocs;

public class GraphRAG {
    private final String workingDir;
    private final String domain;
    private final List<String> exampleQueries;
    private final List<String> entityTypes;
    private final GeminiLLMService llmService;
    private final GeminiEmbeddingService embeddingService;
    private final ObjectMapper objectMapper;
    private final Path indexPath;
    private IndexWriter indexWriter;
    private DirectoryReader indexReader;
    private IndexSearcher indexSearcher;
    private final StandardAnalyzer analyzer;
    
    public static class Config {
        private final GeminiLLMService llmService;
        private final GeminiEmbeddingService embeddingService;
        
        public Config(GeminiLLMService llmService, GeminiEmbeddingService embeddingService) {
            this.llmService = llmService;
            this.embeddingService = embeddingService;
        }
    }
    
    public static class GraphRAGResult {
        private final String response;
        private final List<String> references;
        
        public GraphRAGResult(String response, List<String> references) {
            this.response = response;
            this.references = references;
        }
        
        public String getResponse() { return response; }
        public List<String> getReferences() { return references; }
    }
    
    public GraphRAG(String workingDir, String domain, List<String> exampleQueries, 
                   List<String> entityTypes, Config config) {
        this.workingDir = workingDir;
        this.domain = domain;
        this.exampleQueries = exampleQueries;
        this.entityTypes = entityTypes;
        this.llmService = config.llmService;
        this.embeddingService = config.embeddingService;
        this.objectMapper = new ObjectMapper();
        this.analyzer = new StandardAnalyzer();
        
        // Create working directory if it doesn't exist
        this.indexPath = Paths.get(workingDir, "lucene_index");
        try {
            Files.createDirectories(indexPath);
            initializeIndex();
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize index: " + e.getMessage(), e);
        }
    }
    
    private void initializeIndex() throws IOException {
        FSDirectory directory = FSDirectory.open(indexPath);
        IndexWriterConfig config = new IndexWriterConfig(analyzer);
        indexWriter = new IndexWriter(directory, config);
        
        // Create initial reader and searcher
        if (DirectoryReader.indexExists(directory)) {
            indexReader = DirectoryReader.open(directory);
            indexSearcher = new IndexSearcher(indexReader);
        }
    }
    
    public CompletableFuture<Void> async_insert(String content, Map<String, Object> metadata) {
        return CompletableFuture.runAsync(() -> {
            try {
                // Get embedding for the content
                float[] embedding = embeddingService.getEmbedding(content).get();
                
                // Create Lucene document
                Document doc = new Document();
                doc.add(new TextField("content", content, Field.Store.YES));
                doc.add(new StoredField("embedding", objectMapper.writeValueAsString(embedding)));
                
                // Add metadata fields
                if (metadata != null) {
                    for (Map.Entry<String, Object> entry : metadata.entrySet()) {
                        doc.add(new StoredField(entry.getKey(), entry.getValue().toString()));
                    }
                }
                
                // Add to index
                indexWriter.addDocument(doc);
                indexWriter.commit();
                
                // Refresh reader and searcher
                DirectoryReader newReader = DirectoryReader.openIfChanged(indexReader);
                if (newReader != null) {
                    indexReader.close();
                    indexReader = newReader;
                    indexSearcher = new IndexSearcher(indexReader);
                }
                
                // Update embedding model
                embeddingService.updateModel(content);
                
            } catch (Exception e) {
                throw new RuntimeException("Failed to insert content: " + e.getMessage(), e);
            }
        });
    }
    
    public CompletableFuture<GraphRAGResult> async_query(String query) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Get embedding for the query
                float[] queryEmbedding = embeddingService.getEmbedding(query).get();
                
                // Search for relevant documents
                QueryParser parser = new QueryParser("content", analyzer);
                Query luceneQuery = parser.parse(query);
                TopDocs results = indexSearcher.search(luceneQuery, 5);
                
                // Collect relevant documents and their scores
                List<String> relevantDocs = new ArrayList<>();
                List<String> references = new ArrayList<>();
                
                for (ScoreDoc scoreDoc : results.scoreDocs) {
                    Document doc = indexSearcher.doc(scoreDoc.doc);
                    relevantDocs.add(doc.get("content"));
                    
                    // Add reference with metadata if available
                    StringBuilder reference = new StringBuilder();
                    reference.append("Source ").append(scoreDoc.doc + 1).append(": ");
                    if (doc.get("type") != null) {
                        reference.append("[").append(doc.get("type")).append("] ");
                    }
                    if (doc.get("timestamp") != null) {
                        reference.append("(").append(doc.get("timestamp")).append(") ");
                    }
                    references.add(reference.toString());
                }
                
                // Build context for LLM
                StringBuilder context = new StringBuilder();
                context.append("### Context:\n");
                for (int i = 0; i < relevantDocs.size(); i++) {
                    context.append("\n").append(references.get(i)).append("\n");
                    context.append(relevantDocs.get(i)).append("\n");
                }
                
                // Generate response using LLM
                String systemPrompt = String.format("""
                    You are a web security analysis assistant. Analyze the provided context and answer the query.
                    Domain: %s
                    Focus on security implications, vulnerabilities, and potential risks.
                    Be specific and reference the sources in your response.
                    """, domain);
                
                String response = llmService.generateResponse(
                    context.toString() + "\n\n### Query:\n" + query,
                    systemPrompt
                ).get();
                
                return new GraphRAGResult(response, references);
                
            } catch (Exception e) {
                throw new RuntimeException("Failed to process query: " + e.getMessage(), e);
            }
        });
    }
    
    public void close() {
        try {
            if (indexWriter != null) {
                indexWriter.close();
            }
            if (indexReader != null) {
                indexReader.close();
            }
            embeddingService.shutdown();
            llmService.shutdown();
        } catch (IOException e) {
            throw new RuntimeException("Error closing resources: " + e.getMessage(), e);
        }
    }
} 