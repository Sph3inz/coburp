package com.pentest.browser;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.time.Instant;
import java.time.Duration;
import java.util.stream.Collectors;

public class WebTrafficCollector {
    private final CopyOnWriteArrayList<HttpRequestResponse> trafficData;
    private WebTrafficConfig config;
    private long currentTokenCount;
    private final Object lock = new Object();
    
    public WebTrafficCollector(WebTrafficConfig config) {
        this.trafficData = new CopyOnWriteArrayList<>();
        this.config = config;
        this.currentTokenCount = 0;
    }
    
    public void setConfig(WebTrafficConfig config) {
        this.config = config;
    }
    
    public void captureTraffic(HttpRequestResponse traffic) {
        if (!isAllowedDomain(traffic.getDomain())) {
            return;
        }
        
        synchronized (lock) {
            long trafficTokens = traffic.getTotalTokens();
            
            // If adding this traffic would exceed the token limit, remove oldest entries
            while (currentTokenCount + trafficTokens > config.getMaxTokens() && !trafficData.isEmpty()) {
                HttpRequestResponse oldest = trafficData.get(0);
                trafficData.remove(0);
                currentTokenCount -= oldest.getTotalTokens();
            }
            
            // Add new traffic if it fits within token limit
            if (currentTokenCount + trafficTokens <= config.getMaxTokens()) {
                trafficData.add(traffic);
                currentTokenCount += trafficTokens;
            }
        }
    }
    
    public void flushData() {
        synchronized (lock) {
            trafficData.clear();
            currentTokenCount = 0;
        }
    }
    
    public String aggregateTraffic() {
        if (trafficData.isEmpty()) {
            return "No web traffic data collected.";
        }
        
        StringBuilder analysis = new StringBuilder();
        analysis.append("=== Web Traffic Analysis ===\n");
        analysis.append("Total Requests: ").append(trafficData.size()).append("\n");
        analysis.append("Time Range: ")
               .append(getTimeRange())
               .append("\n\n");
        
        // Group by domain for summary
        analysis.append("=== Domain Summary ===\n");
        trafficData.stream()
                  .map(HttpRequestResponse::getDomain)
                  .distinct()
                  .forEach(domain -> {
                      long domainCount = trafficData.stream()
                                                  .filter(t -> domain.equals(t.getDomain()))
                                                  .count();
                      analysis.append(domain).append(": ").append(domainCount).append(" requests\n");
                  });
        analysis.append("\n");
        
        // Detailed traffic data
        analysis.append("=== Detailed Traffic ===\n");
        trafficData.forEach(traffic -> 
            analysis.append(traffic.toAnalysisString(
                config.isIncludeRequests(), 
                config.isIncludeResponses()
            )).append("\n")
        );
        
        return analysis.toString();
    }
    
    private String getTimeRange() {
        if (trafficData.isEmpty()) return "N/A";
        
        Instant earliest = trafficData.stream()
                                    .map(HttpRequestResponse::getTimestamp)
                                    .min(Instant::compareTo)
                                    .orElse(Instant.now());
                                    
        Instant latest = trafficData.stream()
                                   .map(HttpRequestResponse::getTimestamp)
                                   .max(Instant::compareTo)
                                   .orElse(Instant.now());
                                   
        Duration duration = Duration.between(earliest, latest);
        return String.format("%s to %s (Duration: %d minutes)", 
            earliest, latest, duration.toMinutes());
    }
    
    private boolean isAllowedDomain(String domain) {
        if (domain == null) return false;
        return config.isDomainAllowed(domain);
    }
    
    public boolean isWithinTokenLimit() {
        return currentTokenCount < config.getMaxTokens();
    }
    
    public long getCurrentTokenCount() {
        return currentTokenCount;
    }
    
    public List<HttpRequestResponse> getTrafficData() {
        return new ArrayList<>(trafficData);
    }
    
    public WebTrafficConfig getConfig() {
        return config;
    }
} 