package com.pentest.browser;

import java.util.Map;
import java.util.List;
import java.io.File;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Arrays;
import java.util.HashMap;
import java.time.Instant;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Orchestrator implements Agent {
    private static final String SYSTEM_INSTRUCTIONS = """
        I am your web traffic analysis copilot focusing on defensive security analysis.
        
        My guidelines:
        - I focus on direct observations from videos and traffic data
        - I analyze traffic patterns and data flows objectively
        - I help understand application behavior and architecture
        - I identify technical implementation details
        - I provide clear, concise insights
        - I stay focused on your immediate question/prompt
        - **Do not plan any steps or actions that are outside the scope of my available tools or capabilities.**
        
        Available Tools:
        1. Video Analysis Tool
           - Can analyze screen recordings for visual patterns
           - Useful for understanding UI/UX flows
           - Can identify security-relevant UI elements
           - Helps track user interactions
           
        2. Web Traffic Analysis Tool
           - Analyzes HTTP requests and responses in real-time
           - Identifies patterns in API usage and data flow
           - Detects potential vulnerabilities
           - Maps application structure and endpoints
           - Highlights security misconfigurations
           - Identifies authentication mechanisms
           - Detects sensitive data exposure
        
        Response Formatting:
        - Code blocks use syntax highlighting: ```language```
        - Important points are marked with â€¢
        - Section headers use ###
        - Technical terms use `backticks`
        - Lists use simple bullet points
        """;
    
    private static final String GOAL_IDENTIFICATION_PROMPT = """
        Based on the user's prompt, identify their primary goal and any sub-goals.
        Format your response in XML as follows:
        <goal>Primary goal here</goal>
        <subgoals>
        - First sub-goal
        - Second sub-goal
        </subgoals>
        <reasoning>Brief explanation of why these were identified as the goals</reasoning>
        """;
    
    private static final String TOOL_SELECTION_PROMPT = """
        Given the identified goal and available tools, determine the next best action.
        Consider:
        1. Which tool is most appropriate for the current goal. (For example, use "video analysis" when visual evaluation is needed.)
        2. What specific prompt/query to send to the tool.
        3. How the tool's output will help achieve the goal.
        
        Format your response in XML exactly as follows:
        <action>
            <tool>tool to call</tool>
            <prompt>Specific prompt/query for the tool</prompt>
            <reasoning>Why this tool and prompt were chosen</reasoning>
        </action>
        Ensure that the <tool> tag returns a canonical tool name (e.g., "video analysis") for proper internal parsing.
        Do not include any extraneous formatting markers (such as "xml") in your response output.
        """;
    
    private static final String RESPONSE_EVALUATION_PROMPT = """
        Evaluate the tool's response and determine next steps.
        Consider:
        1. Has the goal been achieved?
        2. Is the response sufficient and accurate?
        3. Are there remaining aspects to investigate?
        
        Format your response in XML:
        <evaluation>
            <status>CONTINUE or COMPLETE</status>
            <confidence>0-100</confidence>
            <reasoning>Why this decision was made</reasoning>
            <next_steps>What should be done next (if CONTINUE)</next_steps>
        </evaluation>
        """;
    
    private final GeminiClient geminiClient;
    private final WebTrafficCollector trafficCollector;
    private final String geminiApiKey;
    private final GraphRAGClient graphRagClient;
    private final PythonServiceManager pythonServiceManager;
    
    public Orchestrator(GeminiClient geminiClient, WebTrafficCollector trafficCollector, String geminiApiKey) {
        this.geminiClient = geminiClient;
        this.trafficCollector = trafficCollector;
        this.geminiApiKey = geminiApiKey;
        
        // Initialize Python service
        Path workingDir = Paths.get(System.getProperty("user.home"), ".pentest-browser");
        this.pythonServiceManager = new PythonServiceManager(workingDir);
        try {
            pythonServiceManager.startService();
        } catch (IOException e) {
            throw new RuntimeException("Failed to start Python service: " + e.getMessage(), e);
        }
        
        this.graphRagClient = new GraphRAGClient("http://localhost:8000");
    }
    
    public void cleanup() {
        pythonServiceManager.stopService();
    }
    
    @Override
    public String processPrompt(String prompt, Map<String, Object> context) {
        try {
            // Create new action history for this prompt
            ActionHistory history = new ActionHistory(prompt);
            
            // Step 1: Identify the goal
            String goalResponse = geminiClient.generateChatResponse(
                geminiApiKey,
                SYSTEM_INSTRUCTIONS + "\n\n" + GOAL_IDENTIFICATION_PROMPT + "\n\nUser Prompt: " + prompt,
                0.3f,
                false
            );
            
            // Extract goal from XML response
            String goal = extractFromXml(goalResponse, "goal");
            history.setIdentifiedGoal(goal);
            history.addAction("GOAL_IDENTIFICATION", "Identified user's goal", goalResponse);
            
            StringBuilder finalResponse = new StringBuilder();
            finalResponse.append("### Goal Identification\n");
            finalResponse.append("I understand your goal is: ").append(goal).append("\n\n");
            
            // Main reasoning loop
            while (history.getTurnCount() < 15) {
                history.incrementTurn();
                
                // Step 2: Select tool and generate prompt
                String toolSelectionResponse = geminiClient.generateChatResponse(
                    geminiApiKey,
                    SYSTEM_INSTRUCTIONS + "\n\n" + TOOL_SELECTION_PROMPT + "\n\n" + history.getContextForPrompt(),
                    0.3f,
                    false
                );
                
                history.addAction("TOOL_SELECTION", "Selected next tool and action", toolSelectionResponse);
                
                // Normalize the tool name for consistency
                String selectedTool = normalizeToolName(extractFromXml(toolSelectionResponse, "tool"));
                String toolPrompt = extractFromXml(toolSelectionResponse, "prompt");
                
                finalResponse.append("### Step ").append(history.getTurnCount()).append("\n");
                finalResponse.append("Thinking: I'll use ").append(selectedTool)
                           .append(" to ").append(extractFromXml(toolSelectionResponse, "reasoning"))
                           .append("\n\n");
                
                // Step 3: Execute tool action
                String toolResponse = executeToolAction(selectedTool, toolPrompt, context);
                history.addAction("TOOL_EXECUTION", "Executed " + selectedTool, toolResponse);
                
                // Step 4: Evaluate response
                String evaluationResponse = geminiClient.generateChatResponse(
                    geminiApiKey,
                    SYSTEM_INSTRUCTIONS + "\n\n" + RESPONSE_EVALUATION_PROMPT + "\n\n" + 
                    history.getContextForPrompt() + "\n\nTool Response: " + toolResponse,
                    0.3f,
                    false
                );
                
                history.addAction("RESPONSE_EVALUATION", "Evaluated tool response", evaluationResponse);
                
                String status = extractFromXml(evaluationResponse, "status");
                int confidence = Integer.parseInt(extractFromXml(evaluationResponse, "confidence"));
                String reasoning = extractFromXml(evaluationResponse, "reasoning");
                
                finalResponse.append("Result: ").append(toolResponse).append("\n\n");
                finalResponse.append("Evaluation: ").append(reasoning).append("\n");
                finalResponse.append("Confidence: ").append(confidence).append("%\n\n");
                
                if ("COMPLETE".equals(status) || confidence >= 90) {
                    finalResponse.append("### Conclusion\n");
                    finalResponse.append("I've achieved the goal with high confidence.\n");
                    break;
                }
            }
            
            if (history.getTurnCount() >= 15) {
                finalResponse.append("\n### Note\n");
                finalResponse.append("Reached maximum number of steps (15). If you need more analysis, please ask a follow-up question.\n");
            }
            
            return finalResponse.toString();
            
        } catch (Exception e) {
            return "Error processing request: " + e.getMessage();
        }
    }
    
    private String executeToolAction(String tool, String prompt, Map<String, Object> context) throws IOException {
        switch (tool.toLowerCase()) {
            case "video analysis":
                if (context.containsKey("lastRecordedPath")) {
                    String videoPath = (String) context.get("lastRecordedPath");
                    File videoFile = new File(videoPath);
                    if (videoPath != null && videoFile.exists()) {
                        try {
                            // Upload the video file to obtain a valid file URI
                            String uploadedVideoUri = GeminiClient.uploadVideo(geminiApiKey, videoFile);
                            return geminiClient.generateMultiVideoResponse(
                                geminiApiKey,
                                prompt,
                                List.of(uploadedVideoUri)
                            );
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            throw new IOException("Video upload interrupted", e);
                        }
                    }
                }
                return "No recent video recording available for analysis.";
                
            case "web traffic analysis":
                if (context.containsKey("includeWebTraffic") && (boolean)context.get("includeWebTraffic")) {
                    try {
                        // Get the latest traffic data from collector
                        String trafficData = trafficCollector.aggregateTraffic();
                        
                        // Insert traffic data into GraphRAG with metadata
                        Map<String, Object> metadata = new HashMap<>();
                        metadata.put("timestamp", Instant.now().toString());
                        metadata.put("type", "web_traffic");
                        metadata.put("source", "burp_proxy");
                        
                        // Insert into GraphRAG
                        graphRagClient.insertContent(trafficData, metadata).get();
                        
                        // Query GraphRAG with the user's prompt
                        GraphRAGClient.GraphRAGResult result = graphRagClient.queryGraphRAG(prompt).get();
                        
                        // Format response with references
                        StringBuilder response = new StringBuilder();
                        response.append(result.getResponse()).append("\n\n");
                        if (!result.getReferences().isEmpty()) {
                            response.append("References:\n");
                            for (String ref : result.getReferences()) {
                                response.append("- ").append(ref).append("\n");
                            }
                        }
                        return response.toString();
                    } catch (Exception e) {
                        throw new IOException("Error analyzing web traffic: " + e.getMessage(), e);
                    }
                }
                return "Web traffic analysis is not enabled. Please enable it in the configuration.";
                
            default:
                return "Unknown tool: " + tool;
        }
    }
    
    private String extractFromXml(String xml, String tag) {
        Pattern pattern = Pattern.compile("<" + tag + ">(.*?)</" + tag + ">", Pattern.DOTALL);
        Matcher matcher = pattern.matcher(xml);
        return matcher.find() ? matcher.group(1).trim() : "";
    }
    
    private String normalizeToolName(String toolName) {
        if (toolName == null) return "";
        toolName = toolName.trim().toLowerCase();
        // If the tool name contains "video analysis", return the canonical name "video analysis"
        if (toolName.contains("video analysis")) {
            return "video analysis";
        }
        // If the tool name contains "web traffic" or "traffic analysis", return the canonical name
        if (toolName.contains("web traffic") || toolName.contains("traffic analysis")) {
            return "web traffic analysis";
        }
        return toolName;
    }
    
    @Override
    public String getAgentType() {
        return "Orchestrator";
    }
    
    @Override
    public boolean canHandle(String prompt, Map<String, Object> context) {
        return true; // Orchestrator can handle all requests
    }
} 