package com.pentest.browser;

import java.util.Map;
import java.util.List;
import java.io.File;
import java.io.IOException;

public class Orchestrator implements Agent {
    private static final String SYSTEM_INSTRUCTIONS = """
        I am your web traffic analysis copilot focusing on defensive security analysis.
        
        My guidelines:
        - I focus on direct observations from videos and traffic data
        - I analyze traffic patterns and data flows objectively
        - I help understand application behavior and architecture
        - I identify technical implementation details
        - I provide clear, concise insights
        - I stay focused on your immediate question/prompt
        
        Response Formatting:
        - Code blocks use syntax highlighting: ```language```
        - Important points are marked with â€¢
        - Section headers use ###
        - Technical terms use `backticks`
        - Lists use simple bullet points
        
        I will respond directly to your prompt while considering all available data.
        """;
    
    private final GeminiClient geminiClient;
    private final WebTrafficCollector trafficCollector;
    private final String geminiApiKey;
    
    public Orchestrator(GeminiClient geminiClient, WebTrafficCollector trafficCollector, String geminiApiKey) {
        this.geminiClient = geminiClient;
        this.trafficCollector = trafficCollector;
        this.geminiApiKey = geminiApiKey;
    }
    
    @Override
    public String processPrompt(String prompt, Map<String, Object> context) {
        try {
            boolean includeWebTraffic = context.containsKey("includeWebTraffic") && 
                                      (boolean)context.get("includeWebTraffic");
            boolean includeRecording = context.containsKey("includeRecording") && 
                                     (boolean)context.get("includeRecording");
            
            // Check if web traffic is enabled and properly configured
            boolean hasWebTrafficData = includeWebTraffic && 
                                      !trafficCollector.getTrafficData().isEmpty() &&
                                      isTrafficConfigured();
            
            // Check if we have video recordings
            @SuppressWarnings("unchecked")
            List<String> recordingPaths = context.containsKey("recordingPaths") ? 
                (List<String>)context.get("recordingPaths") : null;
            String lastRecordedPath = context.containsKey("lastRecordedPath") ? 
                (String)context.get("lastRecordedPath") : null;
            
            boolean hasVideoData = includeRecording && 
                                 (recordingPaths != null && !recordingPaths.isEmpty() || 
                                  lastRecordedPath != null);
            
            // Build the prompt with available data
            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append(SYSTEM_INSTRUCTIONS)
                        .append("\n\n=== Context ===\n")
                        .append("User Query: ").append(prompt)
                        .append("\n\n");
            
            // Add web traffic data if available
            if (hasWebTrafficData) {
                promptBuilder.append("=== Web Traffic Analysis ===\n")
                            .append(trafficCollector.aggregateTraffic())
                            .append("\n\n");
            }
            
            // Process videos if available
            if (hasVideoData) {
                List<String> videoUris = new java.util.ArrayList<>();
                
                // Process all recordings
                if (recordingPaths != null) {
                    for (String path : recordingPaths) {
                        File videoFile = new File(path);
                        if (videoFile.exists() && videoFile.length() > 0) {
                            try {
                                String uri = GeminiClient.uploadVideo(geminiApiKey, videoFile);
                                if (uri != null && !uri.isEmpty()) {
                                    videoUris.add(uri);
                                }
                            } catch (Exception e) {
                                System.err.println("Error uploading video: " + path);
                            }
                        }
                    }
                }
                
                // Process current recording if exists
                if (lastRecordedPath != null) {
                    File videoFile = new File(lastRecordedPath);
                    if (videoFile.exists() && videoFile.length() > 0) {
                        try {
                            String uri = GeminiClient.uploadVideo(geminiApiKey, videoFile);
                            if (uri != null && !uri.isEmpty()) {
                                videoUris.add(uri);
                            }
                        } catch (Exception e) {
                            System.err.println("Error uploading current recording: " + lastRecordedPath);
                        }
                    }
                }
                
                if (!videoUris.isEmpty()) {
                    return geminiClient.generateMultiVideoResponse(geminiApiKey, promptBuilder.toString(), videoUris);
                }
            }
            
            // If no video data, use regular chat
            return geminiClient.generateChatResponse(geminiApiKey, promptBuilder.toString(), 0.3f, true);
            
        } catch (Exception e) {
            return "Error processing request: " + e.getMessage();
        }
    }
    
    @Override
    public String getAgentType() {
        return "Orchestrator";
    }
    
    @Override
    public boolean canHandle(String prompt, Map<String, Object> context) {
        return true; // Orchestrator can handle all requests
    }
    
    private boolean isTrafficConfigured() {
        WebTrafficConfig config = trafficCollector.getConfig();
        return config.getTargetDomain() != null && !config.getTargetDomain().isEmpty();
    }
} 