package com.pentest.browser;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.ArrayList;
import java.util.HashMap;
import org.json.JSONObject;
import org.json.JSONArray;

public class GeminiLLMService {
    private final String model;
    private final String apiKey;
    private final GeminiClient geminiClient;
    private final ExecutorService executorService;
    private final List<Map<String, String>> conversationHistory;
    
    public GeminiLLMService(String model, String apiKey) {
        this.model = model;
        this.apiKey = apiKey;
        this.geminiClient = new GeminiClient();
        this.executorService = Executors.newFixedThreadPool(2);
        this.conversationHistory = new ArrayList<>();
    }
    
    public CompletableFuture<String> generateResponse(String prompt, String systemPrompt) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Add system prompt if provided
                if (systemPrompt != null && !systemPrompt.isEmpty()) {
                    Map<String, String> systemMessage = new HashMap<>();
                    systemMessage.put("role", "system");
                    systemMessage.put("content", systemPrompt);
                    conversationHistory.add(systemMessage);
                }
                
                // Add user prompt
                Map<String, String> userMessage = new HashMap<>();
                userMessage.put("role", "user");
                userMessage.put("content", prompt);
                conversationHistory.add(userMessage);
                
                // Generate response
                String response = geminiClient.generateChatResponse(
                    apiKey,
                    prompt,
                    0.7f,  // temperature
                    false  // stream
                );
                
                // Add assistant response to history
                Map<String, String> assistantMessage = new HashMap<>();
                assistantMessage.put("role", "assistant");
                assistantMessage.put("content", response);
                conversationHistory.add(assistantMessage);
                
                return response;
            } catch (Exception e) {
                throw new RuntimeException("Error generating response: " + e.getMessage(), e);
            }
        }, executorService);
    }
    
    public CompletableFuture<String> generateStructuredResponse(String prompt, String systemPrompt, String responseSchema) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Build the complete prompt with schema instructions
                StringBuilder fullPrompt = new StringBuilder();
                if (systemPrompt != null && !systemPrompt.isEmpty()) {
                    fullPrompt.append(systemPrompt).append("\n\n");
                }
                
                fullPrompt.append("IMPORTANT: Your response must be a valid JSON object following this schema:\n")
                         .append(responseSchema).append("\n\n")
                         .append("User Query: ").append(prompt);
                
                // Generate response
                String response = geminiClient.generateChatResponse(
                    apiKey,
                    fullPrompt.toString(),
                    0.3f,  // Lower temperature for structured output
                    false
                );
                
                // Validate JSON response
                try {
                    new JSONObject(response);
                    return response;
                } catch (Exception e) {
                    // If not valid JSON, try to extract JSON from markdown code blocks
                    if (response.contains("```json")) {
                        String[] parts = response.split("```json");
                        if (parts.length > 1) {
                            String jsonPart = parts[1].split("```")[0].trim();
                            // Validate extracted JSON
                            new JSONObject(jsonPart);
                            return jsonPart;
                        }
                    }
                    throw new RuntimeException("Invalid JSON response: " + e.getMessage());
                }
            } catch (Exception e) {
                throw new RuntimeException("Error generating structured response: " + e.getMessage(), e);
            }
        }, executorService);
    }
    
    public List<Map<String, String>> getConversationHistory() {
        return new ArrayList<>(conversationHistory);
    }
    
    public void clearConversationHistory() {
        conversationHistory.clear();
    }
    
    public void shutdown() {
        executorService.shutdown();
    }
} 