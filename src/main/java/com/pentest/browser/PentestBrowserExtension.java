package com.pentest.browser;

import burp.api.montoya.BurpExtension;
import burp.api.montoya.MontoyaApi;
import burp.api.montoya.ui.UserInterface;
import burp.api.montoya.ui.menu.Menu;
import burp.api.montoya.ui.menu.MenuItem;
import burp.api.montoya.EnhancedCapability;
import burp.api.montoya.ai.chat.Message;
import burp.api.montoya.ai.chat.Prompt;
import burp.api.montoya.ai.chat.PromptOptions;
import burp.api.montoya.ai.chat.PromptResponse;
import burp.api.montoya.ai.chat.PromptException;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.WritableRaster;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBuffer;
import java.awt.color.ColorSpace;
import java.io.*;
import java.net.Socket;
import java.util.prefs.Preferences;
import javax.imageio.ImageIO;
import javax.imageio.ImageWriter;
import javax.imageio.ImageWriteParam;
import javax.imageio.IIOImage;
import javax.imageio.stream.FileImageOutputStream;
import java.util.concurrent.atomic.AtomicBoolean;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.net.ConnectException;
import java.net.ServerSocket;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.UUID;
import org.jcodec.api.awt.AWTSequenceEncoder;
import org.jcodec.common.io.NIOUtils;
import org.jcodec.common.model.Rational;
import org.jcodec.scale.AWTUtil;
import javax.swing.plaf.basic.BasicScrollBarUI;
import java.awt.Graphics;
import java.awt.Rectangle;
import javax.swing.JButton;
import java.util.Random;
import java.awt.Robot;
import java.awt.AWTException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import org.bytedeco.javacv.*;
import org.bytedeco.ffmpeg.global.avcodec;
import java.awt.image.DataBufferByte;

public class PentestBrowserExtension implements BurpExtension {
    private MontoyaApi api;
    private Preferences prefs;
    private static final String PREF_BROWSER_ID = "browserId";
    private static final String PREF_USE_BURP_BROWSER = "useBurpBrowser";
    private static final int BASE_RECORDING_PORT = 61234;
    private int currentRecordingPort = BASE_RECORDING_PORT;
    private JDialog configDialog;
    private JPanel mainPanel;
    private ButtonGroup browserGroup;
    private Map<String, Browser> detectedBrowsers = new HashMap<>();
    private AtomicBoolean isRecording = new AtomicBoolean(false);
    private Process browserProcess;
    private long browserProcessId;
    private Thread recordingThread;
    private JTextPane chatArea;
    private JTextField inputField;
    private JButton sendButton;
    private JButton configButton;
    private JButton recordButton;
    private JCheckBox includeRecordingCheckbox;
    private JScrollPane chatScrollPane;
    private List<String> recordingPaths = new ArrayList<>();
    private JTextField geminiKeyField;
    private Rectangle browserWindowBounds;
    private static final int WINDOW_DETECTION_TIMEOUT = 10000;
    private String lastRecordedVideoPath = null;
    private FFmpegFrameRecorder recorder;
    private Java2DFrameConverter frameConverter;
    private String currentRecordingPath;
    private static final int FRAME_RATE = 15;
    private long firstFrameTime = 0;
    private String currentSessionId;
    private File framesDirectory;
    private List<String> currentFramePaths = new ArrayList<>();
    private Robot robot;
    private com.sun.jna.platform.win32.WinDef.HWND browserWindowHandle;
    private JDialog windowSelectionDialog;
    private List<WindowInfo> detectedWindows = new ArrayList<>();
    private GeminiClient geminiClient;
    private WebTrafficConfig webTrafficConfig;
    private WebTrafficCollector webTrafficCollector;
    private BurpHttpHandler httpHandler;
    private JCheckBox includeWebTrafficCheckbox;
    private JButton webTrafficConfigButton;

    private static class Browser {
        String id;
        String name;
        String path;
        String regKey;

        Browser(String id, String name, String path, String regKey) {
            this.id = id;
            this.name = name;
            this.path = path;
            this.regKey = regKey;
        }

        @Override
        public String toString() {
            return name;
        }
    }

    private static class WindowInfo {
        com.sun.jna.platform.win32.WinDef.HWND handle;
        String title;
        int processId;
        Rectangle bounds;

        WindowInfo(com.sun.jna.platform.win32.WinDef.HWND handle, String title, int processId, Rectangle bounds) {
            this.handle = handle;
            this.title = title;
            this.processId = processId;
            this.bounds = bounds;
        }

        @Override
        public String toString() {
            return title;
        }
    }

    @Override
    public void initialize(MontoyaApi api) {
        this.api = api;
        this.prefs = Preferences.userRoot().node(this.getClass().getName());
        this.geminiClient = new GeminiClient();
        
        // Initialize web traffic components
        this.webTrafficConfig = new WebTrafficConfig();
        this.webTrafficCollector = new WebTrafficCollector(webTrafficConfig);
        this.httpHandler = new BurpHttpHandler(webTrafficCollector);
        
        // Register HTTP handler
        api.http().registerHttpHandler(httpHandler);
        
        api.extension().setName("Pentest Browser AI");
        api.logging().logToOutput("Pentest Browser AI Extension initialized");
        api.logging().logToOutput("Version: 1.0.0");
        
        // Continue with normal initialization
        detectBrowsers();
        SwingUtilities.invokeLater(() -> createUI());

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            cleanup();
            api.logging().logToOutput("Extension cleanup completed");
        }));
    }

    @Override
    public Set<EnhancedCapability> enhancedCapabilities() {
        return Set.of(EnhancedCapability.AI_FEATURES);
    }

    private void createUI() {
        mainPanel = new JPanel(new BorderLayout(0, 0));  // Remove spacing
        mainPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        mainPanel.setBackground(new Color(28, 32, 36));

        // Top panel with modern design
        JPanel topPanel = new JPanel(new BorderLayout(10, 0));
        topPanel.setBackground(new Color(28, 32, 36));
        topPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
        
        // Recording and traffic options panel
        JPanel optionsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 0));
        optionsPanel.setOpaque(false);
        
        recordButton = new JButton("Record");
        styleButton(recordButton, new Color(45, 49, 58));
        recordButton.setPreferredSize(new Dimension(80, 32));
        recordButton.addActionListener(e -> toggleRecording());
        
        includeRecordingCheckbox = new JCheckBox("Include Recording");
        includeRecordingCheckbox.setFont(new Font("Segoe UI", Font.PLAIN, 12));
        includeRecordingCheckbox.setForeground(new Color(200, 200, 200));
        includeRecordingCheckbox.setBackground(new Color(28, 32, 36));
        
        includeWebTrafficCheckbox = new JCheckBox("Include Web Traffic");
        includeWebTrafficCheckbox.setFont(new Font("Segoe UI", Font.PLAIN, 12));
        includeWebTrafficCheckbox.setForeground(new Color(200, 200, 200));
        includeWebTrafficCheckbox.setBackground(new Color(28, 32, 36));
        
        optionsPanel.add(recordButton);
        optionsPanel.add(includeRecordingCheckbox);
        optionsPanel.add(includeWebTrafficCheckbox);
        
        // Config buttons panel
        JPanel configButtonsPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 10, 0));
        configButtonsPanel.setOpaque(false);
        
        webTrafficConfigButton = new JButton("Traffic Settings");
        styleButton(webTrafficConfigButton, new Color(45, 49, 58));
        webTrafficConfigButton.setPreferredSize(new Dimension(120, 32));
        webTrafficConfigButton.addActionListener(e -> showWebTrafficConfig());
        
        configButton = new JButton("Settings");
        styleButton(configButton, new Color(45, 49, 58));
        configButton.setPreferredSize(new Dimension(80, 32));
        configButton.addActionListener(e -> showConfigDialog());
        
        configButtonsPanel.add(webTrafficConfigButton);
        configButtonsPanel.add(configButton);
        
        topPanel.add(optionsPanel, BorderLayout.WEST);
        topPanel.add(configButtonsPanel, BorderLayout.EAST);

        // Chat area with modern styling
        chatArea = new JTextPane();
        chatArea.setContentType("text/html");
        chatArea.setEditable(false);
        chatArea.setFont(new Font("Segoe UI", Font.PLAIN, 13));
        chatArea.setBackground(new Color(28, 32, 36));
        ((HTMLDocument)chatArea.getDocument()).getStyleSheet().addRule("""
            body { 
                font-family: 'Segoe UI', sans-serif;
                background-color: #1C2024;
                color: #E0E0E0;
                margin: 0;
                padding: 8px;
                line-height: 1.5;
            }
            .message-container { 
                display: flex;
                flex-direction: column;
                margin: 8px 0;
                padding: 16px;
                border-radius: 8px;
                background-color: #2D3239;
            }
            .message-header {
                display: flex;
                align-items: center;
                margin-bottom: 12px;
            }
            .timestamp { 
                font-size: 11px;
                color: #808080;
                margin-right: 8px;
            }
            .sender { 
                font-weight: 500;
                color: #4A9EFF;
            }
            .message { 
                color: #E0E0E0;
                line-height: 1.5;
                word-wrap: break-word;
                white-space: pre-wrap;
            }
            pre {
                background-color: #1E2227;
                border-radius: 4px;
                padding: 12px;
                margin: 8px 0;
                overflow-x: auto;
                font-family: 'Consolas', monospace;
                font-size: 13px;
            }
            code {
                font-family: 'Consolas', monospace;
                background-color: #1E2227;
                padding: 2px 4px;
                border-radius: 3px;
                font-size: 90%;
            }
            h3 {
                color: #4A9EFF;
                margin: 16px 0 8px 0;
                font-size: 15px;
                font-weight: 600;
            }
            ul {
                margin: 8px 0;
                padding-left: 20px;
                list-style-type: 'â€¢ ';
            }
            li {
                margin: 4px 0;
                padding-left: 4px;
            }
        """);
        
        chatScrollPane = new JScrollPane(chatArea);
        chatScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        chatScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        chatScrollPane.setBorder(BorderFactory.createCompoundBorder(
            new RoundedBorder(8, new Color(45, 49, 58)),
            BorderFactory.createEmptyBorder(0, 0, 0, 0)
        ));
        
        // Modern input panel design
        JPanel inputPanel = new JPanel(new BorderLayout(8, 0));
        inputPanel.setBackground(new Color(28, 32, 36));
        inputPanel.setBorder(new EmptyBorder(10, 0, 0, 0));
        
        inputField = new JTextField();
        inputField.setFont(new Font("Segoe UI", Font.PLAIN, 13));
        inputField.setForeground(new Color(230, 230, 230));
        inputField.setBackground(new Color(45, 49, 58));
        inputField.setCaretColor(new Color(230, 230, 230));
        inputField.setBorder(BorderFactory.createCompoundBorder(
            new RoundedBorder(6, new Color(45, 49, 58)),
            BorderFactory.createEmptyBorder(8, 12, 8, 12)
        ));
        
        sendButton = new JButton("Send");
        styleButton(sendButton, new Color(45, 49, 58));
        sendButton.setPreferredSize(new Dimension(80, 36));
        sendButton.addActionListener(e -> sendMessage());
        
        inputField.addActionListener(e -> sendMessage());  // Add enter key support
        
        inputPanel.add(inputField, BorderLayout.CENTER);
        inputPanel.add(sendButton, BorderLayout.EAST);

        // Add components to main panel
        mainPanel.add(topPanel, BorderLayout.NORTH);
        mainPanel.add(chatScrollPane, BorderLayout.CENTER);
        mainPanel.add(inputPanel, BorderLayout.SOUTH);

        // Register the tab
        api.userInterface().registerSuiteTab("Pentest Browser", mainPanel);
        
        // Remove system message
        appendToChatArea("Assistant", "Ready to assist with your penetration testing tasks.");
    }

    private void styleButton(JButton button, Color baseColor) {
        button.setFont(new Font("Segoe UI", Font.PLAIN, 12));
        button.setForeground(new Color(230, 230, 230));
        button.setBackground(baseColor);
        button.setBorder(new RoundedBorder(6, baseColor));
        button.setFocusPainted(false);
        button.setOpaque(true);
        
        button.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                button.setBackground(new Color(
                    Math.min(baseColor.getRed() + 15, 255),
                    Math.min(baseColor.getGreen() + 15, 255),
                    Math.min(baseColor.getBlue() + 15, 255)
                ));
            }
            public void mouseExited(java.awt.event.MouseEvent evt) {
                button.setBackground(baseColor);
            }
        });
    }

    private void toggleRecording() {
        if (!isRecording.get()) {
            startRecording();
            recordButton.setText("Stop");
            recordButton.setBackground(new Color(180, 50, 50));
        } else {
            // When stopping, call stopRecording directly without any window selection
            stopRecording();
            recordButton.setText("Record");
            recordButton.setBackground(new Color(45, 49, 58));
            // Reset window handles and process IDs
            browserWindowHandle = null;
            browserProcessId = 0;
            browserWindowBounds = null;
        }
    }

    private void sendMessage() {
        final String message = inputField.getText().trim();
        if (message.isEmpty()) return;

        // Add user message to chat and reset input.
        appendToChatArea("You", message);
        inputField.setText("");

        // Retrieve Gemini API key from preferences
        String geminiApiKey = prefs.get("gemini.api.key", "");
        if (geminiApiKey.isEmpty()) {
            SwingUtilities.invokeLater(() ->
                appendToChatArea("Assistant", "Gemini API key not set in extension preferences."));
            return;
        }

        // Create context for orchestrator
        Map<String, Object> context = new HashMap<>();
        context.put("includeWebTraffic", includeWebTrafficCheckbox.isSelected());
        context.put("includeRecording", includeRecordingCheckbox.isSelected());
        context.put("recordingPaths", recordingPaths);
        context.put("lastRecordedPath", lastRecordedVideoPath);
        
        // Use orchestrator to handle the request
        Orchestrator orchestrator = new Orchestrator(geminiClient, webTrafficCollector, geminiApiKey);
        
        api.logging().logToOutput("Starting message processing with Orchestrator");
        api.logging().logToOutput("Message length: " + message.length());
        api.logging().logToOutput("Include recording: " + includeRecordingCheckbox.isSelected());
        api.logging().logToOutput("Include web traffic: " + includeWebTrafficCheckbox.isSelected());
        api.logging().logToOutput("Last recorded video path: " + lastRecordedVideoPath);

        // Launch orchestrator operations in a background thread
        new Thread(() -> {
            try {
                String response = orchestrator.processPrompt(message, context);
                if (response == null || response.trim().isEmpty()) {
                    throw new IOException("Received empty response from Orchestrator");
                }
                
                SwingUtilities.invokeLater(() ->
                    appendToChatArea("Assistant", response));
                    
            } catch (Exception e) {
                api.logging().logToError("Error during Orchestrator processing: " + e.getMessage());
                if (e.getStackTrace().length > 0) {
                    api.logging().logToError("Stack trace: " + e.getStackTrace()[0]);
                }
                SwingUtilities.invokeLater(() ->
                    appendToChatArea("Assistant", "An error occurred: " + e.getMessage()));
            }
        }).start();
    }

    private String uploadVideoToGemini(String apiKey, File videoFile) throws IOException, InterruptedException {
        api.logging().logToOutput("\nVideo file details:");
        api.logging().logToOutput("- Path: " + videoFile.getAbsolutePath());
        api.logging().logToOutput("- Size: " + videoFile.length() + " bytes");
        
        // Validate video file format and size
        if (!videoFile.getName().toLowerCase().endsWith(".mp4")) {
            throw new IOException("Video must be in MP4 format");
        }
        
        if (videoFile.length() == 0) {
            throw new IOException("Video file is empty");
        }
        
        if (videoFile.length() > 2L * 1024 * 1024 * 1024) {
            throw new IOException("Video file exceeds 2GB limit");
        }
        
        // Add retry logic for video upload
        int maxRetries = 3;
        int retryCount = 0;
        IOException lastException = null;
        
        while (retryCount < maxRetries) {
            try {
                api.logging().logToOutput("\nAttempt " + (retryCount + 1) + " of " + maxRetries);
                String videoUri = GeminiClient.uploadVideo(apiKey, videoFile);
                if (videoUri != null && !videoUri.isEmpty()) {
                    api.logging().logToOutput("Upload successful!");
                    api.logging().logToOutput("Video URI: " + videoUri);
                    return videoUri;
                }
            } catch (IOException e) {
                lastException = e;
                api.logging().logToError("\nUpload attempt " + (retryCount + 1) + " failed:");
                api.logging().logToError("Error message: " + e.getMessage());
                retryCount++;
                if (retryCount < maxRetries) {
                    api.logging().logToOutput("Waiting 2 seconds before retry...");
                    Thread.sleep(2000);
                }
            }
        }
        
        if (lastException != null) {
            throw lastException;
        }
        throw new IOException("Failed to upload video after " + maxRetries + " attempts");
    }

    private void handleGeminiError(IOException e) {
        String errorMsg = e.getMessage();
        if (errorMsg == null) {
            api.logging().logToError("Null error message from Gemini API");
            SwingUtilities.invokeLater(() ->
                appendToChatArea("Assistant", "An error occurred while processing the request. Please check the logs for details."));
        } else {
            SwingUtilities.invokeLater(() ->
                appendToChatArea("Assistant", "Error processing request: " + errorMsg));
        }
    }

    private void appendToChatArea(String sender, String message) {
        String timestamp = new java.text.SimpleDateFormat("HH:mm:ss").format(new java.util.Date());
        message = message.replace("\\n", "\n");
        String htmlContent = convertMarkdownToHtml(message);

        String htmlMessage = String.format("""
            <div class='message-container'>
                <div class='message-header'>
                    <span class='timestamp'>[%s]</span>
                    <span class='sender'>%s</span>
                </div>
                <div class='message'>%s</div>
            </div>
            """, timestamp, sender, htmlContent);

        try {
            HTMLDocument doc = (HTMLDocument) chatArea.getDocument();
            HTMLEditorKit kit = (HTMLEditorKit) chatArea.getEditorKit();
            kit.insertHTML(doc, doc.getLength(), htmlMessage, 0, 0, null);
            chatArea.setCaretPosition(doc.getLength());
            
            // Ensure the latest message is visible
            SwingUtilities.invokeLater(() -> {
                JScrollBar vertical = chatScrollPane.getVerticalScrollBar();
                vertical.setValue(vertical.getMaximum());
            });
        } catch (Exception e) {
            api.logging().logToError("Error appending chat message: " + e.getMessage());
        }
    }

    private String convertMarkdownToHtml(String markdown) {
        if (markdown == null || markdown.isEmpty()) {
            return "";
        }

        // Convert code blocks with language
        markdown = markdown.replaceAll("```(\\w*)\\n([^`]+)```", "<pre><code class=\"language-$1\">$2</code></pre>");
        
        // Convert inline code
        markdown = markdown.replaceAll("`([^`]+)`", "<code>$1</code>");
        
        // Convert headers
        markdown = markdown.replaceAll("###\\s+([^\n]+)", "<h3>$1</h3>");
        
        // Convert bold text
        markdown = markdown.replaceAll("\\*\\*([^*]+)\\*\\*", "<strong>$1</strong>");
        
        // Convert italic text
        markdown = markdown.replaceAll("\\*([^*]+)\\*", "<em>$1</em>");
        
        // Convert blockquotes
        markdown = markdown.replaceAll("^>\\s+([^\n]+)", "<blockquote>$1</blockquote>");
        
        // Convert unordered lists
        StringBuilder html = new StringBuilder();
        boolean inList = false;
        String[] lines = markdown.split("\n");
        
        for (String line : lines) {
            if (line.trim().startsWith("* ") || line.trim().startsWith("- ")) {
                if (!inList) {
                    html.append("<ul>");
                    inList = true;
                }
                html.append("<li>").append(line.trim().substring(2)).append("</li>");
            } else {
                if (inList) {
                    html.append("</ul>");
                    inList = false;
                }
                html.append(line).append("<br>");
            }
        }
        
        if (inList) {
            html.append("</ul>");
        }
        
        return html.toString();
    }

    private void detectBrowsers() {
        detectedBrowsers = new HashMap<>();

        // Check common installation paths first
        String[][] commonPaths = {
            {"chrome", "Google Chrome", "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"},
            {"chrome", "Google Chrome", "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"},
            {"firefox", "Mozilla Firefox", "C:\\Program Files\\Mozilla Firefox\\firefox.exe"},
            {"firefox", "Mozilla Firefox", "C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe"},
            {"edge", "Microsoft Edge", "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe"},
            {"edge", "Microsoft Edge", "C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe"},
            {"opera", "Opera", "C:\\Program Files\\Opera\\launcher.exe"},
            {"opera", "Opera", "C:\\Program Files (x86)\\Opera\\launcher.exe"},
            {"brave", "Brave", "C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe"},
            {"brave", "Brave", "C:\\Program Files (x86)\\BraveSoftware\\Brave-Browser\\Application\\brave.exe"}
        };

        // Check common installation paths first
        for (String[] browserPath : commonPaths) {
            File browser = new File(browserPath[2]);
            if (browser.exists() && !detectedBrowsers.containsKey(browserPath[0])) {
                detectedBrowsers.put(browserPath[0], new Browser(browserPath[0], browserPath[1], browser.getAbsolutePath(), null));
                api.logging().logToOutput("Found " + browserPath[1] + " at: " + browser.getAbsolutePath());
            }
        }

        // Only check registry if browser wasn't found in common paths
        String[][] browserRegInfo = {
            {"chrome", "Google Chrome", "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\chrome.exe"},
            {"edge", "Microsoft Edge", "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\msedge.exe"},
            {"firefox", "Mozilla Firefox", "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\firefox.exe"},
            {"opera", "Opera", "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\opera.exe"},
            {"brave", "Brave", "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\brave.exe"}
        };

        for (String[] info : browserRegInfo) {
            if (detectedBrowsers.containsKey(info[0])) {
                continue; // Skip if browser already found in common paths
            }
            
            try {
                String path = getRegistryValue("HKEY_LOCAL_MACHINE\\" + info[2], "");
                if (path == null || path.isEmpty()) {
                    path = getRegistryValue("HKEY_CURRENT_USER\\" + info[2], "");
                }
                
                if (path != null && !path.isEmpty()) {
                    // Ensure path starts with drive letter
                    if (!path.matches("^[A-Za-z]:\\\\.*")) {
                        if (path.startsWith("\\")) {
                            path = "C:" + path;
                        } else {
                            path = "C:\\" + path;
                        }
                    }
                    
                    File browserFile = new File(path);
                    if (browserFile.exists()) {
                        detectedBrowsers.put(info[0], new Browser(info[0], info[1], browserFile.getAbsolutePath(), info[2]));
                        api.logging().logToOutput("Detected " + info[1] + " at: " + browserFile.getAbsolutePath());
                    } else {
                        api.logging().logToOutput("Found registry entry for " + info[1] + " but file not found at: " + path);
                    }
                }
            } catch (Exception e) {
                api.logging().logToError("Error detecting " + info[1] + ": " + e.getMessage());
            }
        }

        // Log all detected browsers
        api.logging().logToOutput("\nDetected Browsers Summary:");
        for (Browser browser : detectedBrowsers.values()) {
            api.logging().logToOutput(browser.name + ": " + browser.path);
        }
    }

    private String getRegistryValue(String keyPath, String valueName) {
        try {
            Process process = Runtime.getRuntime().exec("reg query \"" + keyPath + "\" /v \"" + valueName + "\"");
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.contains("REG_SZ") || line.contains("REG_EXPAND_SZ")) {
                    String value = line.substring(line.indexOf("REG_")).split("\\s+", 3)[2];
                    // Clean up the path
                    value = value.trim().replace("\"", "");
                    return value;
                }
            }
        } catch (Exception e) {
            api.logging().logToError("Registry query error: " + e.getMessage());
        }
        return null;
    }

    private void createConfigDialog() {
        configDialog = new JDialog((java.awt.Frame) SwingUtilities.getWindowAncestor(mainPanel), "Browser Configuration", true);
        configDialog.setLayout(new BorderLayout());
        
        JPanel dialogPanel = new JPanel();
        dialogPanel.setLayout(new BoxLayout(dialogPanel, BoxLayout.Y_AXIS));
        dialogPanel.setBorder(new EmptyBorder(20, 20, 20, 20));

        // Add Gemini API Key panel
        JPanel geminiPanel = new JPanel(new BorderLayout(5, 5));
        JLabel geminiLabel = new JLabel("Gemini API Key:");
        // Pre-fill the field with the saved API key (if any)
        geminiKeyField = new JTextField(prefs.get("gemini.api.key", ""));
        geminiPanel.add(geminiLabel, BorderLayout.WEST);
        geminiPanel.add(geminiKeyField, BorderLayout.CENTER);
        geminiPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        dialogPanel.add(geminiPanel);
        dialogPanel.add(Box.createVerticalStrut(10));

        // Browser selection panel
        JPanel selectionPanel = new JPanel();
        selectionPanel.setLayout(new BoxLayout(selectionPanel, BoxLayout.Y_AXIS));
        selectionPanel.setBorder(BorderFactory.createTitledBorder("Browser Selection"));
        selectionPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Detect browsers first
        detectBrowsers();

        browserGroup = new ButtonGroup();
        
        // Add Burp Browser option
        JRadioButton burpBrowserRadio = new JRadioButton("Use Burp Suite Browser");
        burpBrowserRadio.setActionCommand("burp");
        browserGroup.add(burpBrowserRadio);
        selectionPanel.add(burpBrowserRadio);
        selectionPanel.add(Box.createVerticalStrut(5));

        // Add detected browsers
        for (Browser browser : detectedBrowsers.values()) {
            JRadioButton radio = new JRadioButton(browser.name);
            radio.setActionCommand(browser.id); // Set the browser ID as action command
            browserGroup.add(radio);
            selectionPanel.add(radio);
            selectionPanel.add(Box.createVerticalStrut(5));
            
            // Select if it was previously selected
            if (!prefs.getBoolean(PREF_USE_BURP_BROWSER, true) && 
                browser.id.equals(prefs.get(PREF_BROWSER_ID, ""))) {
                radio.setSelected(true);
            }
        }

        // Select Burp Browser if no other browser is selected
        if (browserGroup.getSelection() == null) {
            burpBrowserRadio.setSelected(true);
        }

        dialogPanel.add(selectionPanel);
        dialogPanel.add(Box.createVerticalStrut(10));

        // Buttons panel
        JPanel buttonsPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton saveButton = new JButton("Save");
        JButton cancelButton = new JButton("Cancel");
        
        saveButton.addActionListener(e -> {
            ButtonModel selection = browserGroup.getSelection();
            if (selection == null) {
                api.logging().logToError("No browser selected");
                return;
            }
            // Save the Gemini API key from the text field
            String geminiKey = geminiKeyField.getText().trim();
            prefs.put("gemini.api.key", geminiKey);

            String selectedCommand = selection.getActionCommand();
            boolean usingBurpBrowser = "burp".equals(selectedCommand);
            
            prefs.putBoolean(PREF_USE_BURP_BROWSER, usingBurpBrowser);
            if (!usingBurpBrowser) {
                prefs.put(PREF_BROWSER_ID, selectedCommand);
                Browser browser = detectedBrowsers.get(selectedCommand);
                api.logging().logToOutput("Settings saved - Using " + browser.name);
            } else {
                api.logging().logToOutput("Settings saved - Using Burp Suite Browser");
            }
            
            configDialog.setVisible(false);
        });

        cancelButton.addActionListener(e -> configDialog.setVisible(false));

        buttonsPanel.add(saveButton);
        buttonsPanel.add(cancelButton);

        // Add components to dialog
        dialogPanel.add(buttonsPanel);

        configDialog.add(dialogPanel);
        configDialog.pack();
        configDialog.setResizable(false);
    }

    private void showConfigDialog() {
        if (configDialog == null) {
            createConfigDialog();
        }
        
        if (configDialog.isVisible()) {
            configDialog.toFront();
            return;
        }

        // Center the dialog relative to the main window
        if (mainPanel != null) {
            java.awt.Window window = SwingUtilities.getWindowAncestor(mainPanel);
            if (window != null) {
                configDialog.setLocationRelativeTo(window);
            }
        }
        configDialog.setVisible(true);
    }

    private void cleanup() {
        // Stop recording first if it's running
        if (isRecording.get()) {
            stopRecording();
        }
        
        // Clean up browser process if it exists
        if (browserProcess != null) {
            try {
                Runtime.getRuntime().exec("taskkill /F /T /PID " + browserProcessId);
            } catch (IOException e) {
                api.logging().logToError("Error killing browser process: " + e.getMessage());
            }
            browserProcess = null;
            browserProcessId = 0;
        }
        
        // Clean up recording files
        if (!recordingPaths.isEmpty()) {
            for (String path : recordingPaths) {
                try {
                    File file = new File(path);
                    if (file.exists() && !file.delete()) {
                        file.deleteOnExit(); // Fallback to delete on JVM exit
                    }
                } catch (Exception e) {
                    api.logging().logToError("Error deleting recording file: " + path);
                }
            }
            recordingPaths.clear();
        }
        
        // Clear all threads and resources
        if (recordingThread != null && recordingThread.isAlive()) {
            recordingThread.interrupt();
            try {
                recordingThread.join(2000);
            } catch (InterruptedException e) {
                api.logging().logToError("Error waiting for recording thread to terminate: " + e.getMessage());
            }
            recordingThread = null;
        }
        
        // Reset all flags
        isRecording.set(false);
        
        api.logging().logToOutput("Extension cleanup completed - All resources released");
    }

    private boolean waitForBrowserWindow() {
        api.logging().logToOutput("Waiting for browser window to appear...");
        com.sun.jna.platform.win32.User32 user32 = com.sun.jna.platform.win32.User32.INSTANCE;
        long startTime = System.currentTimeMillis();

        // Store existing windows before browser launch
        Set<String> existingWindows = new HashSet<>();
        user32.EnumWindows((hwnd, pointer) -> {
            char[] windowText = new char[512];
            user32.GetWindowText(hwnd, windowText, 512);
            existingWindows.add(new String(windowText).trim());
            return true;
        }, null);

        // Add small delay to allow browser to start
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            return false;
        }

        while (System.currentTimeMillis() - startTime < WINDOW_DETECTION_TIMEOUT) {
            // Enumerate all windows and check for new browser window
            final com.sun.jna.platform.win32.WinDef.HWND[] foundHwnd = new com.sun.jna.platform.win32.WinDef.HWND[1];
            
            user32.EnumWindows((hwnd, pointer) -> {
                com.sun.jna.ptr.IntByReference pid = new com.sun.jna.ptr.IntByReference();
                user32.GetWindowThreadProcessId(hwnd, pid);
                
                if (pid.getValue() == browserProcessId) {
                    char[] windowText = new char[512];
                    user32.GetWindowText(hwnd, windowText, 512);
                    String title = new String(windowText).trim();
                    
                    // Only consider windows that weren't present before and are visible
                    if (!title.isEmpty() && !existingWindows.contains(title) && user32.IsWindowVisible(hwnd)) {
                        api.logging().logToOutput("Found new browser window: " + title);
                    foundHwnd[0] = hwnd;
                        return false; // Stop enumeration
                    }
                }
                return true;
            }, null);
            
            if (foundHwnd[0] != null) {
                // Store window handle for future reference
                browserWindowHandle = foundHwnd[0];

                // Get the window rect
                com.sun.jna.platform.win32.WinDef.RECT rect = new com.sun.jna.platform.win32.WinDef.RECT();
                com.sun.jna.platform.win32.WinDef.RECT clientRect = new com.sun.jna.platform.win32.WinDef.RECT();
                
                if (user32.GetWindowRect(browserWindowHandle, rect) && user32.GetClientRect(browserWindowHandle, clientRect)) {
                    // Calculate the non-client area (borders, title bar)
                    int borderWidth = ((rect.right - rect.left) - clientRect.right) / 2;
                    int titleHeight = ((rect.bottom - rect.top) - clientRect.bottom) - borderWidth;
                    
                    // Calculate client area position in screen coordinates
                    int clientX = rect.left + borderWidth;
                    int clientY = rect.top + titleHeight;
                    
                    // Store the client area bounds with calculated screen coordinates
                    browserWindowBounds = new Rectangle(
                        clientX,
                        clientY,
                        clientRect.right,
                        clientRect.bottom
                    );
                    
                    api.logging().logToOutput("Detected browser window bounds: " + browserWindowBounds);
                    return true;
                }
            }
            
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                break;
            }
        }
        
        api.logging().logToError("No matching browser window found after " + 
            (System.currentTimeMillis() - startTime) + "ms");
        return false;
    }

    private boolean updateBrowserWindow() {
        if (browserProcessId == 0 || browserWindowHandle == null) {
            return false;
        }

        com.sun.jna.platform.win32.User32 user32 = com.sun.jna.platform.win32.User32.INSTANCE;
        
        // Verify the window still exists and is visible
        if (!user32.IsWindow(browserWindowHandle) || !user32.IsWindowVisible(browserWindowHandle)) {
            return false;
        }

        // Get the window rect
        com.sun.jna.platform.win32.WinDef.RECT rect = new com.sun.jna.platform.win32.WinDef.RECT();
        com.sun.jna.platform.win32.WinDef.RECT clientRect = new com.sun.jna.platform.win32.WinDef.RECT();
        
        if (user32.GetWindowRect(browserWindowHandle, rect) && user32.GetClientRect(browserWindowHandle, clientRect)) {
            // Calculate the non-client area (borders, title bar)
            int borderWidth = ((rect.right - rect.left) - clientRect.right) / 2;
            int titleHeight = ((rect.bottom - rect.top) - clientRect.bottom) - borderWidth;
            
            // Calculate client area position in screen coordinates
            int clientX = rect.left + borderWidth;
            int clientY = rect.top + titleHeight;
            
            // Update the client area bounds with calculated screen coordinates
            browserWindowBounds = new Rectangle(
                clientX,
                clientY,
                clientRect.right,
                clientRect.bottom
            );
            
            return true;
        }
        
        return false;
    }

    private void startRecording() {
        if (isRecording.get()) {
            api.logging().logToOutput("Recording is already in progress");
            return;
        }

        // Only show window selection when starting a new recording
        if (browserWindowHandle != null && browserWindowBounds != null) {
            // If we already have a window selected, use it
            startRecordingAfterWindowSelection();
        } else {
            // Find all browser windows
            List<WindowInfo> windows = findBrowserWindows();
            
            if (windows.isEmpty()) {
                api.logging().logToOutput("No browser windows found");
                // Launch new browser if none found
                launchNewBrowser();
            } else if (windows.size() == 1) {
                // If only one window, use it directly
                WindowInfo window = windows.get(0);
                browserWindowHandle = window.handle;
                browserProcessId = window.processId;
                browserWindowBounds = window.bounds;
                startRecordingAfterWindowSelection();
            } else {
                // Show window selection dialog for multiple windows
                showWindowSelectionDialog(windows);
            }
        }
    }

    private void launchNewBrowser() {
            if (!prefs.getBoolean(PREF_USE_BURP_BROWSER, true)) {
                String browserId = prefs.get(PREF_BROWSER_ID, "");
                Browser browser = detectedBrowsers.get(browserId);
                if (browser == null) {
                    api.logging().logToError("Selected browser not found. ID: " + browserId);
                    return;
                }
                
            try {
                int debugPort = 9222 + new Random().nextInt(1000);
                ProcessBuilder pb = new ProcessBuilder(
                    browser.path,
                    "--remote-debugging-port=" + debugPort,
                    "--user-data-dir=" + System.getProperty("java.io.tmpdir") + "/chrome_debug_" + debugPort,
                    "--no-first-run",
                    "--no-default-browser-check",
                    "--window-position=100,100",
                    "--window-size=1024,768",
                    "about:blank"
                );
                Process browserInstance = pb.start();
                browserProcess = browserInstance;
                
                // Get process ID using reflection for compatibility
                try {
                    java.lang.reflect.Field f = browserInstance.getClass().getDeclaredField("handle");
                    f.setAccessible(true);
                    long handle = f.getLong(browserInstance);
                    browserProcessId = handle;
                } catch (Exception e) {
                    // Fallback to newer Java method if available
                    try {
                browserProcessId = browserInstance.pid();
                    } catch (Exception e2) {
                        api.logging().logToError("Could not get process ID: " + e2.getMessage());
                        return;
                    }
                }
                
                // Wait for the window to appear
                if (waitForBrowserWindow()) {
                    startRecordingAfterWindowSelection();
                } else {
                    api.logging().logToError("Failed to detect launched browser window");
                    stopRecording();
                }
            } catch (Exception e) {
                api.logging().logToError("Failed to launch browser: " + e.getMessage());
                stopRecording();
            }
        }
    }

    private void showWindowSelectionDialog(List<WindowInfo> windows) {
        if (windowSelectionDialog != null && windowSelectionDialog.isVisible()) {
            windowSelectionDialog.dispose();
        }

        windowSelectionDialog = new JDialog((java.awt.Frame) SwingUtilities.getWindowAncestor(mainPanel), "Select Browser Window", true);
        windowSelectionDialog.setLayout(new BorderLayout());
        
        JPanel dialogPanel = new JPanel();
        dialogPanel.setLayout(new BoxLayout(dialogPanel, BoxLayout.Y_AXIS));
        dialogPanel.setBorder(new EmptyBorder(20, 20, 20, 20));
        dialogPanel.setBackground(new Color(28, 32, 36));

        JLabel instructionLabel = new JLabel("Select the browser window to record:");
        instructionLabel.setForeground(new Color(230, 230, 230));
        instructionLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        dialogPanel.add(instructionLabel);
        dialogPanel.add(Box.createVerticalStrut(10));

        JList<WindowInfo> windowList = new JList<>(windows.toArray(new WindowInfo[0]));
        windowList.setBackground(new Color(45, 49, 58));
        windowList.setForeground(new Color(230, 230, 230));
        windowList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        windowList.setBorder(new RoundedBorder(6, new Color(45, 49, 58)));
        
        JScrollPane scrollPane = new JScrollPane(windowList);
        scrollPane.setAlignmentX(Component.LEFT_ALIGNMENT);
        dialogPanel.add(scrollPane);
        dialogPanel.add(Box.createVerticalStrut(10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        buttonPanel.setBackground(new Color(28, 32, 36));
        JButton selectButton = new JButton("Select");
        JButton cancelButton = new JButton("Cancel");
        
        styleButton(selectButton, new Color(45, 49, 58));
        styleButton(cancelButton, new Color(45, 49, 58));

        selectButton.addActionListener(e -> {
            WindowInfo selected = windowList.getSelectedValue();
            if (selected != null) {
                browserWindowHandle = selected.handle;
                browserProcessId = selected.processId;
                browserWindowBounds = selected.bounds;
                windowSelectionDialog.dispose();
                startRecordingAfterWindowSelection();
            }
        });

        cancelButton.addActionListener(e -> {
            windowSelectionDialog.dispose();
            isRecording.set(false);
            SwingUtilities.invokeLater(() -> {
                recordButton.setText("Record");
                recordButton.setBackground(new Color(45, 49, 58));
            });
        });

        buttonPanel.add(selectButton);
        buttonPanel.add(cancelButton);
        buttonPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        dialogPanel.add(buttonPanel);

        windowSelectionDialog.add(dialogPanel);
        windowSelectionDialog.pack();
        windowSelectionDialog.setSize(400, 300);
        windowSelectionDialog.setLocationRelativeTo(mainPanel);
        windowSelectionDialog.setVisible(true);
    }

    private void startRecordingAfterWindowSelection() {
        if (browserWindowHandle == null) {
            api.logging().logToError("No window selected for recording");
            return;
        }

        try {
            // Initialize screen capture robot
            try {
                robot = new Robot();
            } catch (AWTException e) {
                throw new IOException("Failed to initialize screen capture: " + e.getMessage(), e);
            }

            recordingPaths.clear();
            isRecording.set(true);
            recordingThread = new Thread(this::recordScreen);
            recordingThread.start();
            api.logging().logToOutput("Screen recording started for selected window");
        } catch (Exception e) {
            api.logging().logToError("Failed to start recording: " + e.getMessage());
            stopRecording();
        }
    }

    private List<WindowInfo> findBrowserWindows() {
        List<WindowInfo> windows = new ArrayList<>();
        com.sun.jna.platform.win32.User32 user32 = com.sun.jna.platform.win32.User32.INSTANCE;

        user32.EnumWindows((hwnd, pointer) -> {
            if (!user32.IsWindowVisible(hwnd)) {
                return true;
            }

            char[] windowText = new char[512];
            user32.GetWindowText(hwnd, windowText, 512);
            String title = new String(windowText).trim();

            if (!title.isEmpty()) {
                com.sun.jna.ptr.IntByReference pidRef = new com.sun.jna.ptr.IntByReference();
                user32.GetWindowThreadProcessId(hwnd, pidRef);
                int pid = pidRef.getValue();

                // Get window bounds
                com.sun.jna.platform.win32.WinDef.RECT rect = new com.sun.jna.platform.win32.WinDef.RECT();
                com.sun.jna.platform.win32.WinDef.RECT clientRect = new com.sun.jna.platform.win32.WinDef.RECT();
                
                if (user32.GetWindowRect(hwnd, rect) && user32.GetClientRect(hwnd, clientRect)) {
                    int borderWidth = ((rect.right - rect.left) - clientRect.right) / 2;
                    int titleHeight = ((rect.bottom - rect.top) - clientRect.bottom) - borderWidth;
                    
                    Rectangle bounds = new Rectangle(
                        rect.left + borderWidth,
                        rect.top + titleHeight,
                        clientRect.right,
                        clientRect.bottom
                    );

                    // Check if this is a browser window
                    if (isBrowserProcess(pid)) {
                        windows.add(new WindowInfo(hwnd, title, pid, bounds));
                    }
                }
            }
            return true;
        }, null);

        return windows;
    }

    private boolean isBrowserProcess(int pid) {
        try {
            Process process = Runtime.getRuntime().exec("tasklist /FI \"PID eq " + pid + "\" /FO CSV /NH");
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line = reader.readLine();
            
            if (line != null) {
                // Remove quotes and split by comma
                String[] parts = line.replace("\"", "").split(",");
                if (parts.length > 0) {
                    String processName = parts[0].toLowerCase();
                    return processName.contains("chrome") || 
                           processName.contains("firefox") || 
                           processName.contains("edge") || 
                           processName.contains("opera") || 
                           processName.contains("brave");
                }
            }
            return false;
        } catch (Exception e) {
            api.logging().logToError("Error checking process: " + e.getMessage());
            return false;
        }
    }

    private void recordScreen() {
        currentSessionId = UUID.randomUUID().toString();
        api.logging().logToOutput("Starting new recording session: " + currentSessionId);

        // Only wait for browser window if we don't already have one
        if (browserWindowHandle == null && !waitForBrowserWindow()) {
            api.logging().logToError("Failed to detect launched Chrome browser window after timeout");
            isRecording.set(false);
            return;
        }

        String userHome = System.getProperty("user.home");
        String baseDir = userHome + File.separator + "PentestBrowser";
        File recordingsDir = new File(baseDir + File.separator + "recordings");
        if (!recordingsDir.exists() && !recordingsDir.mkdirs()) {
            api.logging().logToError("Failed to create recordings directory");
            isRecording.set(false);
            return;
        }
        currentRecordingPath = recordingsDir.getAbsolutePath() + File.separator + "recording_" + currentSessionId + ".mp4";
        api.logging().logToOutput("Recording will be saved to: " + currentRecordingPath);

        // Ensure we have valid browser window bounds
        if (browserWindowBounds == null || browserWindowBounds.width <= 0 || browserWindowBounds.height <= 0) {
            api.logging().logToError("Invalid browser window bounds");
            isRecording.set(false);
            return;
        }

        // Initialize with current window bounds
        Rectangle captureArea = new Rectangle(browserWindowBounds);
        
        api.logging().logToOutput("Starting capture with area: " + captureArea.toString());
        api.logging().logToOutput("Target frame rate: " + FRAME_RATE + " fps");

        try {
            // Initialize FFmpeg recorder with proper color space settings
            recorder = new FFmpegFrameRecorder(currentRecordingPath, captureArea.width, captureArea.height);
            recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264);
            recorder.setFormat("mp4");
            recorder.setFrameRate(FRAME_RATE);
            recorder.setVideoQuality(0); // Best quality
            recorder.setPixelFormat(org.bytedeco.ffmpeg.global.avutil.AV_PIX_FMT_YUV420P); // Standard pixel format
            recorder.setVideoOption("preset", "ultrafast");
            recorder.setVideoOption("tune", "zerolatency");
            recorder.setVideoOption("crf", "18"); // High quality, visually lossless
            recorder.start();

            frameConverter = new Java2DFrameConverter();

            long frameInterval = 1000000000L / FRAME_RATE; // nanoseconds between frames
            long lastFrameTime = System.nanoTime();
            long startTime = System.currentTimeMillis();
            int frameCount = 0;
            int droppedFrames = 0;

            while (isRecording.get()) {
                long currentTime = System.nanoTime();
                long elapsedNanos = currentTime - lastFrameTime;
                
                if (elapsedNanos >= frameInterval) {
                    try {
                        // Update browser window position and get new capture area
                        if (!updateBrowserWindow()) {
                            api.logging().logToOutput("Browser window no longer detected, stopping recording");
                            break;
                        }

                        // Update capture area with current window bounds
                        captureArea = new Rectangle(browserWindowBounds);

                        // Create a compatible BufferedImage with correct color model
                        BufferedImage frame = new BufferedImage(
                            captureArea.width,
                            captureArea.height,
                            BufferedImage.TYPE_3BYTE_BGR
                        );
                        Graphics2D g = frame.createGraphics();
                        try {
                            g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
                            g.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
                            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                            
                            // Capture the exact browser window area
                            BufferedImage capture = robot.createScreenCapture(captureArea);
                            
                            // Draw the captured image at (0,0) in the frame
                            g.drawImage(capture, 0, 0, null);
                            capture.flush();
                        } finally {
                            g.dispose();
                        }
                        
                        if (!isBlankImage(frame)) {
                            try {
                                org.bytedeco.javacv.Frame convertedFrame = frameConverter.convert(frame);
                                recorder.record(convertedFrame);
                                frameCount++;
                                
                                if (frameCount % FRAME_RATE == 0) {
                                    long elapsedSeconds = (System.currentTimeMillis() - startTime) / 1000;
                                    double actualFps = frameCount / (double)elapsedSeconds;
                                    api.logging().logToOutput(String.format(
                                        "Recording stats - Frames: %d, Time: %ds, FPS: %.2f, Dropped: %d",
                                        frameCount, elapsedSeconds, actualFps, droppedFrames
                                    ));
                                }
                            } catch (Exception e) {
                                api.logging().logToError("Error recording frame: " + e.getMessage());
                                droppedFrames++;
                            }
                        }
                        
                        frame.flush();
                        lastFrameTime = currentTime;
                    } catch (Exception ex) {
                        api.logging().logToError("Error capturing frame: " + ex.getMessage());
                        droppedFrames++;
                    }
                } else {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        break;
                    }
                }
            }

            // Log final statistics
            long totalTime = (System.currentTimeMillis() - startTime) / 1000;
            api.logging().logToOutput(String.format(
                "Recording finished - Total frames: %d, Duration: %ds, Dropped frames: %d",
                frameCount, totalTime, droppedFrames
            ));

            // Stop recording
            recorder.stop();
            recorder.release();
            lastRecordedVideoPath = currentRecordingPath;
            api.logging().logToOutput("Video recording completed successfully");

        } catch (Exception e) {
            api.logging().logToError("Error in recording: " + e.getMessage());
            if (recorder != null) {
                try {
                    recorder.stop();
                    recorder.release();
                } catch (Exception ex) {
                    api.logging().logToError("Error stopping recorder: " + ex.getMessage());
                }
            }
        } finally {
            recorder = null;
            frameConverter = null;
        }
    }

    private boolean isBlankImage(BufferedImage image) {
        int width = image.getWidth();
        int height = image.getHeight();
        
        // Sample points in a grid pattern for better coverage
        int gridSize = 10;
        int stepX = width / gridSize;
        int stepY = height / gridSize;
        int totalSamples = 0;
        int blankSamples = 0;
        
        for (int x = 0; x < width; x += stepX) {
            for (int y = 0; y < height; y += stepY) {
                totalSamples++;
                int rgb = image.getRGB(x, y);
                // Consider a pixel blank if it's white or very close to white
                int red = (rgb >> 16) & 0xFF;
                int green = (rgb >> 8) & 0xFF;
                int blue = rgb & 0xFF;
                if (red > 250 && green > 250 && blue > 250) {
                    blankSamples++;
                }
            }
        }
        
        // Consider frame blank if more than 98% of sampled pixels are white
        return (blankSamples / (double)totalSamples) > 0.98;
    }

    private void stopRecording() {
        if (!isRecording.get()) {
            api.logging().logToOutput("No recording in progress");
            return;
        }

        api.logging().logToOutput("Stopping recording...");
        isRecording.set(false);
        
        SwingUtilities.invokeLater(() -> {
            recordButton.setText("Record");
            recordButton.setBackground(new Color(45, 49, 58));
        });
        
        // Wait for recording thread to finish
        if (recordingThread != null) {
            try {
                recordingThread.join(10000);
                if (recordingThread.isAlive()) {
                    recordingThread.interrupt();
                    recordingThread.join(3000);
                }
            } catch (InterruptedException e) {
                api.logging().logToError("Error waiting for recording thread: " + e.getMessage());
            }
            recordingThread = null;
        }

        // Clean up recorder if it exists
        if (recorder != null) {
            try {
                recorder.stop();
                recorder.release();
                recorder = null;
                api.logging().logToOutput("Video recorder stopped successfully");
            } catch (Exception e) {
                api.logging().logToError("Error stopping recorder: " + e.getMessage());
            }
        }

        // Verify the recorded video
        if (currentRecordingPath != null) {
            File videoFile = new File(currentRecordingPath);
            if (videoFile.exists() && videoFile.length() > 0) {
                lastRecordedVideoPath = currentRecordingPath;
                double fileSizeMB = videoFile.length() / (1024.0 * 1024.0);
                api.logging().logToOutput(String.format("Recording saved: %s (%.2f MB)", 
                    currentRecordingPath, fileSizeMB));
                
                SwingUtilities.invokeLater(() -> 
                    appendToChatArea("System", String.format(
                        "Recording completed successfully. Video saved to: %s (%.2f MB)",
                        currentRecordingPath, fileSizeMB
                    ))
                );
            } else {
                api.logging().logToError("Failed to create video file or file is empty: " + currentRecordingPath);
            }
        }
    }

    private void showWebTrafficConfig() {
        WebTrafficConfigDialog dialog = new WebTrafficConfigDialog(
            (java.awt.Frame) SwingUtilities.getWindowAncestor(mainPanel),
            webTrafficConfig,
            webTrafficCollector
        );
        dialog.setVisible(true);
    }

    private static class RoundedBorder extends javax.swing.border.AbstractBorder {
        private final int radius;
        private final Color color;

        RoundedBorder(int radius, Color color) {
            this.radius = radius;
            this.color = color;
        }

        @Override
        public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
            Graphics2D g2 = (Graphics2D) g.create();
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            g2.setColor(color);
            g2.drawRoundRect(x, y, width - 1, height - 1, radius, radius);
            g2.dispose();
        }

        @Override
        public Insets getBorderInsets(Component c) {
            return new Insets(radius/2, radius/2, radius/2, radius/2);
        }

        @Override
        public Insets getBorderInsets(Component c, Insets insets) {
            insets.left = insets.top = insets.right = insets.bottom = radius/2;
            return insets;
        }
    }
}
