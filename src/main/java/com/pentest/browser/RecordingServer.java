package com.pentest.browser;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import org.jcodec.api.awt.AWTSequenceEncoder;
import org.jcodec.common.io.NIOUtils;
import org.jcodec.common.model.Rational;

public class RecordingServer {
    private static final AtomicBoolean isRunning = new AtomicBoolean(true);
    private static final int FRAME_RATE = 15;
    private static final int MAX_RETRIES = 3;

    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println("Usage: RecordingServer <port>");
            return;
        }

        int port = Integer.parseInt(args[0]);
        System.out.println("PORT:" + port);
        System.out.println("RecordingServer starting up...");

        // First terminate any existing processes using our port
        try {
            Process netstat = Runtime.getRuntime().exec("netstat -ano | findstr :" + port);
            BufferedReader netstatReader = new BufferedReader(new InputStreamReader(netstat.getInputStream()));
            String line;
            while ((line = netstatReader.readLine()) != null) {
                if (line.contains("LISTENING")) {
                    String[] parts = line.trim().split("\\s+");
                    if (parts.length > 4) {
                        String pid = parts[parts.length - 1];
                        System.out.println("Found process using port " + port + " with PID: " + pid);
                        Runtime.getRuntime().exec("taskkill /F /PID " + pid);
                    }
                }
            }

            // Give some time for the process to terminate
            Thread.sleep(2000);

            // Verify port is available
            try (ServerSocket testSocket = new ServerSocket(port)) {
                testSocket.close();
                System.out.println("Port " + port + " is now available");
            } catch (IOException e) {
                System.err.println("Port " + port + " is still in use after cleanup");
                System.exit(1);
                return;
            }

        } catch (Exception e) {
            System.out.println("Error checking port usage: " + e.getMessage());
        }

        // Try to create the server socket with port retry logic
        ServerSocket serverSocket = null;
        try {
            serverSocket = new ServerSocket(port);
            System.out.println("Server listening on port " + port);

            while (isRunning.get()) {
                try {
                    Socket clientSocket = serverSocket.accept();
                    System.out.println("Client connected from " + clientSocket.getInetAddress());
                    
                    DataInputStream dis = new DataInputStream(clientSocket.getInputStream());
                    String sessionId = dis.readUTF();
                    System.out.println("Processing session: " + sessionId);
                    
                    List<String> framePaths = new ArrayList<>();
                    int frameSize;
                    
                    // Read all frame paths
                    while ((frameSize = dis.readInt()) > 0) {
                        byte[] framePathBytes = new byte[frameSize];
                        dis.readFully(framePathBytes);
                        String framePath = new String(framePathBytes);
                        framePaths.add(framePath);
                    }
                    
                    System.out.println("Received " + framePaths.size() + " frames to process");
                    
                    if (!framePaths.isEmpty()) {
                        // Get dimensions from first frame
                        BufferedImage firstFrame = ImageIO.read(new File(framePaths.get(0)));
                        int width = firstFrame.getWidth();
                        int height = firstFrame.getHeight();
                        firstFrame.flush();
                        
                        // Determine output path based on first frame path
                        String outputPath = new File(framePaths.get(0)).getParentFile().getParentFile()
                            .getAbsolutePath() + File.separator + "recordings" + File.separator + 
                            "recording_" + sessionId + ".mp4";
                        
                        File outputFile = new File(outputPath);
                        System.out.println("Creating video at: " + outputPath);
                        
                        // Create video encoder with proper frame rate
                        AWTSequenceEncoder encoder = AWTSequenceEncoder.createSequenceEncoder(outputFile, FRAME_RATE);
                        encoder.finish(); // Set keyframe interval
                        
                        // Process each frame
                        long startTime = System.currentTimeMillis();
                        int processedFrames = 0;
                        
                        for (String framePath : framePaths) {
                            BufferedImage frame = ImageIO.read(new File(framePath));
                            if (frame != null) {
                                // Ensure frame dimensions match
                                if (frame.getWidth() != width || frame.getHeight() != height) {
                                    BufferedImage resized = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
                                    Graphics2D g = resized.createGraphics();
                                    g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
                                    g.drawImage(frame, 0, 0, width, height, null);
                                    g.dispose();
                                    frame = resized;
                                }
                                
                                encoder.encodeImage(frame);
                                frame.flush();
                                processedFrames++;
                                
                                // Log progress every 30 frames
                                if (processedFrames % 30 == 0) {
                                    long elapsed = System.currentTimeMillis() - startTime;
                                    System.out.println(String.format("Processed %d/%d frames (%.1f fps)", 
                                        processedFrames, framePaths.size(), 
                                        (processedFrames * 1000.0) / elapsed));
                                }
                            }
                        }
                        
                        // Finalize video
                        encoder.finish();
                        System.out.println("Video creation completed: " + outputPath);
                    }
                    
                    clientSocket.close();
                    
                } catch (Exception e) {
                    System.out.println("Error processing client request: " + e.getMessage());
                    e.printStackTrace();
                }
            }
        } catch (Exception e) {
            System.out.println("Server error: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (serverSocket != null && !serverSocket.isClosed()) {
                try {
                    serverSocket.close();
                } catch (IOException e) {
                    System.out.println("Error closing server socket: " + e.getMessage());
                }
            }
        }
    }
}